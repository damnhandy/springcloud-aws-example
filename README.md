# Spring Boot with Spring Cloud AWS Example

This is a small sample application that uses a SpringBoot service with Spring Cloud AWS to source
certain configuration elements. Additionally, it uses the AWS Cloud Development Kit (CDK) to
provision the AWS resources that the application needs in order to deploy into AWS.

## Objectives

This project defines a simple SpringBoot service that connects to a MySQL datatbase. The deployment
will handle the provisioning of credentials, such as passwords and certificates. The application
will resolve the credentials differently depending on the environment it was deployed to. The
SpringBoot application uses Spring profiles to determine the right strategy. When using the `local`
or `docker` profiles, it will use the Spring
[`configtree`](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.configtree)
to resolve the credentials. In AWS, the `aws` profile is used and the
[Spring Cloud AWS library](https://docs.awspring.io/spring-cloud-aws/docs/2.3.0-RC1/reference/html/index.html#integrating-your-spring-cloud-application-with-the-aws-secrets-manager)
handles the resolution of secrets.

When deployed to AWS, a codebuild job is uses to populate the database using the
[Flyway CLI](https://flywaydb.org/documentation/command/migrate). A
[Lambda trigger](lambdas/codebuild-trigger/s3-trigger.ts) is used to trigger the CodeBuild project
whenever the `data-migration.zip` file is uploaded to S3. When running under Docker Compose, we
leverage the MySQL containers bootstrap mechanism to create the table and provision the data.

## Strategy

THis project is structured as a single project that builds and deploys all assets when deployed to
either docker compose or in AWS.

## Provisioning Secrets for local development.

A key element of this project is to promote proper credential handling. As such, the project
attempts to simulate a hands-off credentials management approach. In a local environment, the DB
credentials are are generated and stored in the `./credentials` directory. When running under Docker
Compose, these values are injected into the environment via the Docker Secrets mechanism. When
deployed in AWS, the DB credentials are generated by AWS Secrets Manager and referenced in the
application via Spring Cloud AWS.

Prior to running the application in either local model, run the `prepare_credentials.sh` script.
This will generated the following:

- The MySQL root password
- The MySQL appuser password (used by the SpringBoot application)
- The MySQL certificates
- A Java KeyStore that contains the self-signed MySQL root CA

Practically ALL SpringBoot/MySQL examples end up creating a JDBC connection with `sslMode=DISABLED`
as it's generally easier. Because these types of examples end up making their way into production,
this project demonstrates how to use TLS with MySQL.

In order to do this, we generate the MySQL certificates first so we can create a KeyStore with the
generated root certificates.

## Local Hybrid Deployment with Docker Compose

In this model, we use Docker Compose to bring up ONLY the MySQL DB so that we can run the SpringBoot
application via an IDE on the Host OS. In order to do this, run the following:

    $ ./prepare_credentials.sh
    $ docker compose up mysql

In your IDE, use the `local` profile to connect to the database.

## Local Deployment with Docker Compose

To run the stack locally, simply run the following commands:

    $ ./prepare_credentials.sh
    $ docker compose build
    $ docker compose up

This will build the container with the SpringBoot application and then launch the MySQL database and
SpringBoot application. The `depends_on` attribute of Docker Compose does not actually force the
SpringBoot app to wait until the MySQL instance is ready for requests. Upon running the stack for
the first time, it is normal to see the SpringBoot app fail connecting to MySQL in the forst few
attempts. The SpringBoot app has a `restart` policy of `always` which will restart the app on
failure. Eventually, the application will stabilize and you should be able to hit the following
URIs:

http://localhost:8080/cars/11 http://localhost:8081/actuator/info
http://localhost:8081/actuator/health

## AWS CDK Deployment

Before deploying to AWS, run the build target:

    npm run build

And then synthesize the stack by running:

    npx cdk synth

And finally deploy the stack:

    npx cdk deploy --all

or if you don't want to deal with the prompts, run:

    npm run deploy
